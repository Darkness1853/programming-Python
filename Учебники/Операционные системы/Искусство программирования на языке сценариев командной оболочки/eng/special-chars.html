<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Special Characters</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.57"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Basics"
HREF="part2.html"><LINK
REL="PREVIOUS"
TITLE="Basics"
HREF="part2.html"><LINK
REL="NEXT"
TITLE="Introduction to Variables and Parameters"
HREF="variables.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="part2.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="variables.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="SPECIAL-CHARS"
>Chapter 3. Special Characters</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SCHARLIST1"
></A
>Special Characters Found In
          Scripts and Elsewhere</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>#</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Comments. </B
>Lines beginning with a <SPAN
CLASS="TOKEN"
>#</SPAN
>
	      (<A
HREF="sha-bang.html#MAGNUMREF"
>with the exception of
	      <SPAN
CLASS="TOKEN"
>#!</SPAN
></A
>) are comments.</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# This line is a comment.</PRE
></TD
></TR
></TABLE
></P
><P
>Comments may also occur following the end of a command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "A comment will follow." # Comment here.
   2&nbsp;#                            ^ Note whitespace before #</PRE
></TD
></TR
></TABLE
></P
><P
>Comments may also follow <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
> at the beginning
	    of a line.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;	# A tab precedes this comment.</PRE
></TD
></TR
></TABLE
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command may not follow a comment on the
	      same line. There is no method of terminating the comment,
	      in order for <SPAN
CLASS="QUOTE"
>"live code"</SPAN
> to begin on the same
	      line. Use a new line for the next command.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Of course, an escaped <SPAN
CLASS="TOKEN"
>#</SPAN
> in an
	    <B
CLASS="COMMAND"
>echo</B
> statement does
	    <I
CLASS="EMPHASIS"
>not</I
> begin a comment. Likewise, a
	    <SPAN
CLASS="TOKEN"
>#</SPAN
> appears in <A
HREF="parameter-substitution.html#PSUB2"
>certain parameter
	    substitution constructs</A
> and in <A
HREF="numerical-constants.html#NUMCONSTANTS"
>	    numerical constant expressions</A
>.

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo "The # here does not begin a comment."
   2&nbsp;echo 'The # here does not begin a comment.'
   3&nbsp;echo The \# here does not begin a comment.
   4&nbsp;echo The # here begins a comment.
   5&nbsp;
   6&nbsp;echo ${PATH#*:}       # Parameter substitution, not a comment.
   7&nbsp;echo $(( 2#101011 ))  # Base conversion, not a comment.
   8&nbsp;
   9&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>

	  The standard <A
HREF="quoting.html#QUOTINGREF"
>quoting and
	  escape</A
> characters (" ' \) escape the #.
	  </P
></TD
></TR
></TABLE
></DIV
><P
>Certain <A
HREF="parameter-substitution.html#PSOREX1"
>pattern matching
	    operations</A
> also use the <SPAN
CLASS="TOKEN"
>#</SPAN
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Command separator [semicolon]. </B
>Permits putting two or more commands on the same
	        line.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo hello; echo there
   2&nbsp;
   3&nbsp;
   4&nbsp;if [ -x "$filename" ]; then    # Note that "if" and "then" need separation.
   5&nbsp;                               # Why?
   6&nbsp;  echo "File $filename exists."; cp $filename $filename.bak
   7&nbsp;else
   8&nbsp;  echo "File $filename not found."; touch $filename
   9&nbsp;fi; echo "File test complete."</PRE
></TD
></TR
></TABLE
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
> sometimes
	      needs to be <A
HREF="escapingsection.html#ESCP"
>escaped</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>;;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Terminator in a <A
HREF="testbranch.html#CASEESAC1"
>case</A
> option [double semicolon]. </B
><A
NAME="DOUBLESEMICOLON"
></A
></P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;case "$variable" in
   2&nbsp;abc)  echo "\$variable = abc" ;;
   3&nbsp;xyz)  echo "\$variable = xyz" ;;
   4&nbsp;esac</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><P
><A
NAME="DOTREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
> command [period]. </B
>Equivalent to <A
HREF="internal.html#SOURCEREF"
>source</A
> (see
		<A
HREF="internal.html#EX38"
>Example 11-20</A
>). This is a bash <A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
>, as a component of a filename. </B
>When working with filenames, a dot is the prefix
		of a <SPAN
CLASS="QUOTE"
>"hidden"</SPAN
> file, a file that an
		<A
HREF="external.html#LSREF"
>ls</A
> will not normally show.
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>touch .hidden-file</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</TT
>
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -al</B
></TT
>	      
 <TT
CLASS="COMPUTEROUTPUT"
>total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</TT
>
 	        </PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
><P
>When considering directory names, <I
CLASS="EMPHASIS"
>a single
		dot</I
> represents the current working directory,
		and <I
CLASS="EMPHASIS"
>two dots</I
> denote the parent
		directory.</P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/projects</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cd .</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/projects</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cd ..</B
></TT
>
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>pwd</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/</TT
>
 	        </PRE
></TD
></TR
></TABLE
>
	      </P
><P
>The <I
CLASS="EMPHASIS"
>dot</I
> often appears as the
	        destination (directory) of a file movement command.</P
><P
>	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>cp /home/bozo/current_work/junk/* .</B
></TT
>
 	        </PRE
></TD
></TR
></TABLE
>
	      </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>.</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><SPAN
CLASS="QUOTE"
>"dot"</SPAN
> character match. </B
>When <A
HREF="regexp.html#REGEXDOT"
>matching
	        characters</A
>, as part of a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
	        <SPAN
CLASS="QUOTE"
>"dot"</SPAN
> matches a single character.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>"</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#DBLQUO"
>partial
	    quoting</A
> [double quote]. </B
><I
CLASS="EMPHASIS"
>"STRING"</I
> preserves (from
	      interpretation) most of the special characters within
	      <I
CLASS="EMPHASIS"
>STRING</I
>. See also <A
HREF="quoting.html"
>Chapter 5</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>'</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#SNGLQUO"
>full
	    quoting</A
> [single quote]. </B
><I
CLASS="EMPHASIS"
>'STRING'</I
> preserves all special
	      characters within <I
CLASS="EMPHASIS"
>STRING</I
>. This is a
	      stronger form of quoting than using <SPAN
CLASS="TOKEN"
>"</SPAN
>.
	      See also <A
HREF="quoting.html"
>Chapter 5</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>,</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#COMMAOP"
>comma
	    operator</A
>. </B
>The <B
CLASS="COMMAND"
>comma operator</B
> links together a
	        series of arithmetic operations. All are evaluated, but only
		the last one is returned.
               <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3"</PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>\</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="escapingsection.html#ESCP"
>escape</A
> [backslash]. </B
>A quoting mechanism for single characters.</P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>\X</B
></TT
>
		<SPAN
CLASS="QUOTE"
>"escapes"</SPAN
> the character
		<I
CLASS="EMPHASIS"
>X</I
>. This has the effect of
		<SPAN
CLASS="QUOTE"
>"quoting"</SPAN
> <I
CLASS="EMPHASIS"
>X</I
>, equivalent
		to <I
CLASS="EMPHASIS"
>'X'</I
>.  The <SPAN
CLASS="TOKEN"
>\</SPAN
> may
		be used to quote <SPAN
CLASS="TOKEN"
>"</SPAN
> and <SPAN
CLASS="TOKEN"
>'</SPAN
>,
		so they are expressed literally.</P
><P
>See <A
HREF="quoting.html"
>Chapter 5</A
> for an in-depth explanation
	        of escaped characters.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>/</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Filename path separator [forward slash]. </B
>Separates the components of a filename (as in
	        <TT
CLASS="FILENAME"
>/home/bozo/projects/Makefile</TT
>).</P
></DIV
><P
>This is also the division <A
HREF="operations.html#AROPS1"
>arithmetic operator</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>`</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="commandsub.html#COMMANDSUBREF"
>command substitution</A
>. </B
>The <B
CLASS="COMMAND"
>`command`</B
> construct makes
		available the output of <B
CLASS="COMMAND"
>command</B
>
		for assignment to a variable. This is also known as
		<A
HREF="commandsub.html#BACKQUOTESREF"
>backquotes</A
> or
		backticks.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>:</SPAN
></DT
><DD
><P
><A
NAME="NULLREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>null command [colon]. </B
>This is the shell equivalent of a
		<SPAN
CLASS="QUOTE"
>"NOP"</SPAN
> (<TT
CLASS="REPLACEABLE"
><I
>no op</I
></TT
>, a
		do-nothing operation). It may be considered a synonym for
		the shell builtin <A
HREF="internal.html#TRUEREF"
>true</A
>. The
		<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> command is itself a
		Bash <A
HREF="internal.html#BUILTINREF"
>builtin</A
>, and its
		<A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
> is
		<SPAN
CLASS="QUOTE"
>"true"</SPAN
> (<SPAN
CLASS="RETURNVALUE"
>0</SPAN
>).</P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;:
   2&nbsp;echo $?   # 0</PRE
></TD
></TR
></TABLE
></P
><P
>Endless loop:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;while :
   2&nbsp;do
   3&nbsp;   operation-1
   4&nbsp;   operation-2
   5&nbsp;   ...
   6&nbsp;   operation-n
   7&nbsp;done
   8&nbsp;
   9&nbsp;# Same as:
  10&nbsp;#    while true
  11&nbsp;#    do
  12&nbsp;#      ...
  13&nbsp;#    done</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Placeholder in if/then test:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if condition
   2&nbsp;then :   # Do nothing and branch ahead
   3&nbsp;else
   4&nbsp;   take-some-action
   5&nbsp;fi</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Provide a placeholder where a binary operation is
	      expected, see <A
HREF="operations.html#ARITHOPS"
>Example 8-2</A
> and <A
HREF="parameter-substitution.html#DEFPARAM"
>default parameters</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${username=`whoami`}
   2&nbsp;# ${username=`whoami`}   Gives an error without the leading :
   3&nbsp;#                        unless "username" is a command or builtin...</PRE
></TD
></TR
></TABLE
></P
><P
>Provide a placeholder where a command is expected in a
	      <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. See <A
HREF="here-docs.html#ANONHEREDOC"
>Example 17-10</A
>.</P
><P
>Evaluate string of variables using
		<A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter substitution</A
>
		(as in <A
HREF="parameter-substitution.html#EX6"
>Example 9-14</A
>).

	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: ${HOSTNAME?} ${USER?} ${MAIL?}
   2&nbsp;#  Prints error message
   3&nbsp;#+ if one or more of essential environmental variables not set.</PRE
></TD
></TR
></TABLE
></P
><P
><B
CLASS="COMMAND"
><A
HREF="parameter-substitution.html#EXPREPL1"
>Variable expansion / substring
	      replacement</A
></B
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <A
HREF="io-redirection.html#IOREDIRREF"
>redirection operator</A
>,
	      truncates a file to zero length, without changing its
	      permissions. If the file did not previously exist,
	      creates it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: &#62; data.xxx   # File "data.xxx" now empty.	      
   2&nbsp;
   3&nbsp;# Same effect as   cat /dev/null &#62;data.xxx
   4&nbsp;# However, this does not fork a new process, since ":" is a builtin.</PRE
></TD
></TR
></TABLE
>
              See also <A
HREF="textproc.html#EX12"
>Example 12-14</A
>.</P
><P
>In combination with the <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
>
	      redirection operator, has no effect on a pre-existing
	      target file (<TT
CLASS="USERINPUT"
><B
>: &#62;&#62; target_file</B
></TT
>).
	      If the file did not previously exist, creates it.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This applies to regular files, not pipes,
	      symlinks, and certain special files.</P
></TD
></TR
></TABLE
></DIV
><P
>May be used to begin a comment line, although this is not
	      recommended. Using <SPAN
CLASS="TOKEN"
>#</SPAN
> for a comment turns
	      off error checking for the remainder of that line, so
	      almost anything may appear in a comment. However,
	      this is not the case with
	      <SPAN
CLASS="TOKEN"
>:</SPAN
>.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;: This is a comment that generates an error, ( if [ $x -eq 3] ).</PRE
></TD
></TR
></TABLE
>
	    </P
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>:</SPAN
>"</SPAN
> also serves as a field
	      separator, in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>, and in the <A
HREF="variables2.html#PATHREF"
>$PATH</A
> variable.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo $PATH</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</TT
></PRE
></TD
></TR
></TABLE
>
	    </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>!</SPAN
></DT
><DD
><P
><A
NAME="NOTREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>reverse (or negate) the sense of
	  a test or exit status [bang]. </B
>The <SPAN
CLASS="TOKEN"
>!</SPAN
> operator inverts the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of the command to which it is applied (see
		<A
HREF="exit-status.html#NEGCOND"
>Example 6-2</A
>). It also inverts
		the meaning of a test operator. This can, for
		example, change the sense of <SPAN
CLASS="QUOTE"
>"equal"</SPAN
>
		( <A
HREF="comparison-ops.html#EQUALSIGNREF"
>=</A
>
		) to <SPAN
CLASS="QUOTE"
>"not-equal"</SPAN
> ( != ). The
		<SPAN
CLASS="TOKEN"
>!</SPAN
> operator is a Bash <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>.</P
></DIV
><P
>In a different context, the <SPAN
CLASS="TOKEN"
>!</SPAN
>
	        also appears in <A
HREF="ivr.html#IVRREF"
>indirect variable
		references</A
>.</P
><P
>In yet another context, from the <I
CLASS="EMPHASIS"
>command
		line</I
>, the <SPAN
CLASS="TOKEN"
>!</SPAN
> invokes the
		Bash <I
CLASS="EMPHASIS"
>history mechanism</I
> (see <A
HREF="histcommands.html"
>Appendix J</A
>). Note that within a script,
		the history mechanism is disabled.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card [asterisk]. </B
>The <SPAN
CLASS="TOKEN"
>*</SPAN
> character serves as a <SPAN
CLASS="QUOTE"
>"wild
	        card"</SPAN
> for filename expansion in
		<A
HREF="globbingref.html"
>globbing</A
>. By itself,
		it matches every filename in a given directory.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo *</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>abs-book.sgml add-drive.sh agram.sh alias.sh</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>The <SPAN
CLASS="TOKEN"
>*</SPAN
> also represents any number
	      (or zero) characters in a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>*</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#AROPS1"
>arithmetic operator</A
>. </B
>In the context of arithmetic operations, the
	        <SPAN
CLASS="TOKEN"
>*</SPAN
> denotes multiplication.</P
></DIV
><P
>A double asterisk, <SPAN
CLASS="TOKEN"
>**</SPAN
>, is the <A
HREF="operations.html#EXPONENTIATIONREF"
>exponentiation
	        operator</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test operator. </B
>Within certain expressions, the <SPAN
CLASS="TOKEN"
>?</SPAN
> indicates
	        a test for a condition.</P
></DIV
><P
>In a <A
HREF="dblparens.html"
>double
	        parentheses construct</A
>, the <SPAN
CLASS="TOKEN"
>?</SPAN
> serves
		as a C-style trinary operator. See <A
HREF="dblparens.html#CVARS"
>Example 9-30</A
>.</P
><P
>In a <A
HREF="parameter-substitution.html#PARAMSUBREF"
>parameter
	        substitution</A
> expression, the <SPAN
CLASS="TOKEN"
>?</SPAN
>
		<A
HREF="parameter-substitution.html#QERRMSG"
>tests whether a variable has been
		set</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>wild card. </B
>The <SPAN
CLASS="TOKEN"
>?</SPAN
> character serves as a
		single-character <SPAN
CLASS="QUOTE"
>"wild card"</SPAN
> for filename
		expansion in <A
HREF="globbingref.html"
>globbing</A
>,
		as well as <A
HREF="regexp.html#QUEXREGEX"
>representing one
		character</A
> in an <A
HREF="regexp.html#EXTREGEX"
>extended
		regular expression</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables.html#VARSUBN"
>Variable
              substitution</A
> (contents of a variable). </B
>	       <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var1=5
   2&nbsp;var2=23skidoo
   3&nbsp;
   4&nbsp;echo $var1     # 5
   5&nbsp;echo $var2     # 23skidoo</PRE
></TD
></TR
></TABLE
>
	       </P
></DIV
><P
>A <SPAN
CLASS="TOKEN"
>$</SPAN
> prefixing a variable name
		indicates the <I
CLASS="EMPHASIS"
>value</I
> the variable
		holds.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>end-of-line. </B
>In a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
	        <SPAN
CLASS="QUOTE"
>"$"</SPAN
> addresses the end of a line of text.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>${}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="parameter-substitution.html#PARAMSUBREF"
>Parameter
              substitution</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$*</SPAN
>, <SPAN
CLASS="TOKEN"
>$@</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="variables2.html#APPREF"
>positional
	    parameters</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$?</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>exit status variable. </B
>The <A
HREF="exit-status.html#EXSREF"
>$? variable</A
>
	        holds the <A
HREF="exit-status.html#EXITSTATUSREF"
>exit status</A
>
		of a command, a <A
HREF="functions.html#FUNCTIONREF"
>function</A
>,
		or of the script itself.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>$$</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>process ID variable. </B
>The <A
HREF="variables2.html#PROCCID"
>$$ variable</A
>
	        holds the <I
CLASS="EMPHASIS"
>process ID</I
> of the script in
		which it appears.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>()</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>command group. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(a=hello; echo $a)</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="IMPORTANT"
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/important.png"
HSPACE="5"
ALT="Important"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A listing of commands within
	      <TT
CLASS="REPLACEABLE"
><I
>parentheses</I
></TT
> starts a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.</P
><P
>Variables inside parentheses, within the subshell, are not
	      visible to the rest of the script. The parent process,
	      the script, <A
HREF="subshells.html#PARVIS"
>cannot read variables
	      created in the child process</A
>, the subshell.
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;( a=321; )	      
   3&nbsp;
   4&nbsp;echo "a = $a"   # a = 123
   5&nbsp;# "a" within parentheses acts like a local variable.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="FORMALPARA"
><P
><B
>array initialization. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Array=(element1 element2 element3)</PRE
></TD
></TR
></TABLE
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{xxx,yyy,zzz,...}</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Brace expansion. </B
><A
NAME="BRACEEXPREF"
></A
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat {file1,file2,file3} &#62; combined_file
   2&nbsp;# Concatenates the files file1, file2, and file3 into combined_file.
   3&nbsp;
   4&nbsp;
   5&nbsp;cp file22.{txt,backup}
   6&nbsp;# Copies "file22.txt" to "file22.backup"</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>A command may act upon a comma-separated list of file specs within
	  <TT
CLASS="REPLACEABLE"
><I
>braces</I
></TT
>.

	     <A
NAME="AEN882"
HREF="#FTN.AEN882"
>[1]</A
>
	  
	  Filename expansion (<A
HREF="globbingref.html"
>globbing</A
>)
	  applies to the file specs between the braces.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>No spaces allowed within the braces
	    <I
CLASS="EMPHASIS"
>unless</I
> the spaces are quoted or escaped.</P
><P
><TT
CLASS="USERINPUT"
><B
>echo {file1,file2}\ :{\ A," B",' C'}</B
></TT
></P
><P
><TT
CLASS="COMPUTEROUTPUT"
>file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</TT
></P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{}</SPAN
></DT
><DD
><P
><A
NAME="CODEBLOCKREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>Block of code [curly brackets]. </B
>Also referred to as an <SPAN
CLASS="QUOTE"
>"inline group"</SPAN
>,
		this construct, in effect, creates an anonymous
		function. However, unlike a <A
HREF="functions.html#FUNCTIONREF"
>function</A
>, the variables
		in a code block remain visible to the remainder of the
		script.</P
></DIV
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>{ local a;
	      a=123; }</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>bash: local: can only be used in a
function</TT
>
 	      </PRE
></TD
></TR
></TABLE
> </P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=123
   2&nbsp;{ a=321; }
   3&nbsp;echo "a = $a"   # a = 321   (value inside code block)
   4&nbsp;
   5&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
><P
>The code block enclosed in braces may have <A
HREF="io-redirection.html#IOREDIRREF"
>I/O redirected</A
> to and from
	      it.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX8"
></A
><P
><B
>Example 3-1. Code blocks and I/O redirection</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Reading lines in /etc/fstab.
   3&nbsp;
   4&nbsp;File=/etc/fstab
   5&nbsp;
   6&nbsp;{
   7&nbsp;read line1
   8&nbsp;read line2
   9&nbsp;} &#60; $File
  10&nbsp;
  11&nbsp;echo "First line in $File is:"
  12&nbsp;echo "$line1"
  13&nbsp;echo
  14&nbsp;echo "Second line in $File is:"
  15&nbsp;echo "$line2"
  16&nbsp;
  17&nbsp;exit 0
  18&nbsp;
  19&nbsp;# Now, how do you parse the separate fields of each line?
  20&nbsp;# Hint: use awk.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RPMCHECK"
></A
><P
><B
>Example 3-2. Saving the results of a code block to a file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# rpm-check.sh
   3&nbsp;
   4&nbsp;# Queries an rpm file for description, listing, and whether it can be installed.
   5&nbsp;# Saves output to a file.
   6&nbsp;# 
   7&nbsp;# This script illustrates using a code block.
   8&nbsp;
   9&nbsp;SUCCESS=0
  10&nbsp;E_NOARGS=65
  11&nbsp;
  12&nbsp;if [ -z "$1" ]
  13&nbsp;then
  14&nbsp;  echo "Usage: `basename $0` rpm-file"
  15&nbsp;  exit $E_NOARGS
  16&nbsp;fi  
  17&nbsp;
  18&nbsp;{ 
  19&nbsp;  echo
  20&nbsp;  echo "Archive Description:"
  21&nbsp;  rpm -qpi $1       # Query description.
  22&nbsp;  echo
  23&nbsp;  echo "Archive Listing:"
  24&nbsp;  rpm -qpl $1       # Query listing.
  25&nbsp;  echo
  26&nbsp;  rpm -i --test $1  # Query whether rpm file can be installed.
  27&nbsp;  if [ "$?" -eq $SUCCESS ]
  28&nbsp;  then
  29&nbsp;    echo "$1 can be installed."
  30&nbsp;  else
  31&nbsp;    echo "$1 cannot be installed."
  32&nbsp;  fi  
  33&nbsp;  echo
  34&nbsp;} &#62; "$1.test"       # Redirects output of everything in block to file.
  35&nbsp;
  36&nbsp;echo "Results of rpm test in file $1.test"
  37&nbsp;
  38&nbsp;# See rpm man page for explanation of options.
  39&nbsp;
  40&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unlike a command group within (parentheses),
	      as above, a code block enclosed by {braces} will
	      <I
CLASS="EMPHASIS"
>not</I
> normally launch a <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.

		<A
NAME="AEN931"
HREF="#FTN.AEN931"
>[2]</A
>

	      </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>{} \;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>pathname. </B
>Mostly used in <A
HREF="moreadv.html#FINDREF"
>find</A
>
		constructs.  This is <I
CLASS="EMPHASIS"
>not</I
> a shell
		<A
HREF="internal.html#BUILTINREF"
>builtin</A
>.</P
></DIV
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>;</SPAN
>"</SPAN
> ends
		the <TT
CLASS="OPTION"
>-exec</TT
> option of a
		<B
CLASS="COMMAND"
>find</B
> command sequence.  It needs
		to be escaped to protect it from interpretation by the
		shell.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
></P
></DIV
><P
><A
NAME="LEFTBRACKET"
></A
><A
HREF="tests.html#IFTHEN"
>Test</A
> expression between <B
CLASS="COMMAND"
>[
	       ]</B
>.  Note that <B
CLASS="COMMAND"
>[</B
> is part of
	       the shell builtin <B
CLASS="COMMAND"
>test</B
> (and a synonym
	       for it), <I
CLASS="EMPHASIS"
>not</I
> a link to the external
	       command <TT
CLASS="FILENAME"
>/usr/bin/test</TT
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>test. </B
></P
></DIV
><P
>Test expression between <SPAN
CLASS="TOKEN"
>[[ ]]</SPAN
> (shell
	       <A
HREF="internal.html#KEYWORDREF"
>keyword</A
>).</P
><P
>See the discussion on the <A
HREF="tests.html#DBLBRACKETS"
>[[ ... ]] construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>array element. </B
></P
></DIV
><P
>In the context of an <A
HREF="arrays.html#ARRAYREF"
>array</A
>,
	       brackets set off the numbering of each element of that array.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Array[1]=slot_1
   2&nbsp;echo ${Array[1]}</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>[ ]</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>range of characters. </B
></P
></DIV
><P
>As part of a <A
HREF="regexp.html#REGEXREF"
>regular
	       expression</A
>, brackets delineate a <A
HREF="regexp.html#BRACKETSREF"
>range of characters</A
> to
	       match.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>(( ))</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>integer expansion. </B
></P
></DIV
><P
>Expand and evaluate integer expression between
	       <SPAN
CLASS="TOKEN"
>(( ))</SPAN
>.</P
><P
>See the discussion on the <A
HREF="dblparens.html"
>(( ... )) construct</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#38;&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#38;</SPAN
> <SPAN
CLASS="TOKEN"
>&#62;&#62;</SPAN
> <SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="io-redirection.html#IOREDIRREF"
>redirection</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;filename</B
></TT
> redirects the output of
	      <TT
CLASS="FILENAME"
>scriptname</TT
> to file
	      <TT
CLASS="FILENAME"
>filename</TT
>. Overwrite
	      <TT
CLASS="FILENAME"
>filename</TT
> if it already exists.</P
><P
><TT
CLASS="USERINPUT"
><B
>command &#38;&#62;filename</B
></TT
> redirects
	      both the <TT
CLASS="FILENAME"
>stdout</TT
> and the
	      <TT
CLASS="FILENAME"
>stderr</TT
> of <TT
CLASS="FILENAME"
>command</TT
>
	      to <TT
CLASS="FILENAME"
>filename</TT
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>command &#62;&#38;2</B
></TT
> redirects
	      <TT
CLASS="FILENAME"
>stdout</TT
> of <TT
CLASS="FILENAME"
>command</TT
>
	      to <TT
CLASS="FILENAME"
>stderr</TT
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>scriptname &#62;&#62;filename</B
></TT
> appends
	    the output of <TT
CLASS="FILENAME"
>scriptname</TT
>
	    to file <TT
CLASS="FILENAME"
>filename</TT
>. If
	    <TT
CLASS="FILENAME"
>filename</TT
> does not already exist,
	    it will be created.</P
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="process-sub.html#PROCESSSUBREF"
>process substitution</A
>. </B
></P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>(command)&#62;</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>&#60;(command)</B
></TT
></P
><P
><A
HREF="comparison-ops.html#LTREF"
>In a different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison
	      operators</A
>.</P
><P
><A
HREF="comparison-ops.html#INTLT"
>In yet another context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#60;</SPAN
>"</SPAN
> and
	      <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>&#62;</SPAN
>"</SPAN
> characters act
	      as <A
HREF="comparison-ops.html#ICOMPARISON1"
>integer comparison
	      operators</A
>. See also <A
HREF="moreadv.html#EX45"
>Example 12-9</A
>.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection used in a <A
HREF="here-docs.html#HEREDOCREF"
>here document</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;&#60;&#60;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection used in a <A
HREF="here-docs.html#HERESTRINGSREF"
>here string</A
>. </B
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
>, <SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="comparison-ops.html#LTREF"
>ASCII
	    comparison</A
>. </B
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;veg1=carrots
   2&nbsp;veg2=tomatoes
   3&nbsp;
   4&nbsp;if [[ "$veg1" &#60; "$veg2" ]]
   5&nbsp;then
   6&nbsp;  echo "Although $veg1 precede $veg2 in the dictionary,"
   7&nbsp;  echo "this implies nothing about my culinary preferences."
   8&nbsp;else
   9&nbsp;  echo "What kind of dictionary are you using, anyhow?"
  10&nbsp;fi</PRE
></TD
></TR
></TABLE
></P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>\&#60;</SPAN
>, <SPAN
CLASS="TOKEN"
>\&#62;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="regexp.html#ANGLEBRAC"
>word
	    boundary</A
> in a <A
HREF="regexp.html#REGEXREF"
>regular
	    expression</A
>. </B
></P
></DIV
><P
><TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>grep '\&#60;the\&#62;' textfile</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>|</SPAN
></DT
><DD
><P
><A
NAME="PIPEREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>pipe. </B
>Passes the output of previous command to the input
		of the next one, or to the shell. This is a method of
		chaining commands together.</P
></DIV
><P
>              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo ls -l | sh
   2&nbsp;#  Passes the output of "echo ls -l" to the shell,
   3&nbsp;#+ with the same result as a simple "ls -l".
   4&nbsp;
   5&nbsp;
   6&nbsp;cat *.lst | sort | uniq
   7&nbsp;# Merges and sorts all ".lst" files, then deletes duplicate lines.</PRE
></TD
></TR
></TABLE
>
	    </P
><TABLE
CLASS="SIDEBAR"
BORDER="1"
CELLPADDING="5"
><TR
><TD
><DIV
CLASS="SIDEBAR"
><A
NAME="AEN1202"
></A
><P
>A pipe, as a classic method of interprocess
	      communication, sends the <TT
CLASS="FILENAME"
>stdout</TT
>
	      of one process to the <TT
CLASS="FILENAME"
>stdin</TT
>
	      of another.  In a typical case, a command,
	      such as <A
HREF="external.html#CATREF"
>cat</A
> or <A
HREF="internal.html#ECHOREF"
>echo</A
>, pipes a stream of data to a
	      <SPAN
CLASS="QUOTE"
>"filter"</SPAN
> (a command that transforms its input)
	      for processing.</P
><P
>  
	      <TT
CLASS="USERINPUT"
><B
>cat $filename1 $filename2 | grep $search_word</B
></TT
>
            </P
></DIV
></TD
></TR
></TABLE
><P
><A
NAME="UCREF"
></A
>The output of a command or commands
	      may be piped to a script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# uppercase.sh : Changes input to uppercase.
   3&nbsp;
   4&nbsp;tr 'a-z' 'A-Z'
   5&nbsp;#  Letter ranges must be quoted
   6&nbsp;#+ to prevent filename generation from single-letter filenames.
   7&nbsp;
   8&nbsp;exit 0</PRE
></TD
></TR
></TABLE
>
              Now, let us pipe the output of <B
CLASS="COMMAND"
>ls -l</B
> to this
	      script.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>ls -l | ./uppercase.sh</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="FILENAME"
>stdout</TT
> of each process in
	       a pipe must be read as the <TT
CLASS="FILENAME"
>stdin</TT
>
	       of the next. If this is not the case, the data stream
	       will <I
CLASS="EMPHASIS"
>block</I
>, and the pipe will not
	       behave as expected.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;cat file1 file2 | ls -l | sort
   2&nbsp;# The output from "cat file1 file2" disappears.</PRE
></TD
></TR
></TABLE
>
             </P
><P
>A pipe runs as a <A
HREF="othertypesv.html#CHILDREF"
>child
	       process</A
>, and therefore cannot alter script
	       variables.
	         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;variable="initial_value"
   2&nbsp;echo "new_value" | read variable
   3&nbsp;echo "variable = $variable"     # variable = initial_value</PRE
></TD
></TR
></TABLE
>
             </P
><P
>If one of the commands in the pipe
	       aborts, this prematurely terminates execution of the
	       pipe. Called a <I
CLASS="EMPHASIS"
>broken pipe</I
>, this
	       condition sends a <I
CLASS="EMPHASIS"
>SIGPIPE</I
> <A
HREF="debugging.html#SIGNALD"
>signal</A
>.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;|</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>force redirection (even if
		the <A
HREF="options.html#NOCLOBBERREF"
>noclobber option</A
>
		is set). </B
>This will forcibly overwrite an existing file.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>||</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#ORREF"
>OR logical operator</A
>. </B
>In a <A
HREF="tests.html#TESTCONSTRUCTS1"
>test
		construct</A
>, the <SPAN
CLASS="TOKEN"
>||</SPAN
> operator causes
		a return of <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> (success) if
		<I
CLASS="EMPHASIS"
>either</I
> of the linked test conditions
		is true.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Run job in background. </B
>A command followed by an <SPAN
CLASS="TOKEN"
>&#38;</SPAN
>
	        will run in the background.</P
></DIV
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>sleep 10 &#38;</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1] 850</TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>[1]+  Done                    sleep 10</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Within a script, commands and even <A
HREF="loops.html#FORLOOPREF1"
>loops</A
> may run in the
	      background.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BGLOOP"
></A
><P
><B
>Example 3-3. Running a loop in the background</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# background-loop.sh
   3&nbsp;
   4&nbsp;for i in 1 2 3 4 5 6 7 8 9 10            # First loop.
   5&nbsp;do
   6&nbsp;  echo -n "$i "
   7&nbsp;done &#38; # Run this loop in background.
   8&nbsp;       # Will sometimes execute after second loop.
   9&nbsp;
  10&nbsp;echo   # This 'echo' sometimes will not display.
  11&nbsp;
  12&nbsp;for i in 11 12 13 14 15 16 17 18 19 20   # Second loop.
  13&nbsp;do
  14&nbsp;  echo -n "$i "
  15&nbsp;done  
  16&nbsp;
  17&nbsp;echo   # This 'echo' sometimes will not display.
  18&nbsp;
  19&nbsp;# ======================================================
  20&nbsp;
  21&nbsp;# The expected output from the script:
  22&nbsp;# 1 2 3 4 5 6 7 8 9 10 
  23&nbsp;# 11 12 13 14 15 16 17 18 19 20 
  24&nbsp;
  25&nbsp;# Sometimes, though, you get:
  26&nbsp;# 11 12 13 14 15 16 17 18 19 20 
  27&nbsp;# 1 2 3 4 5 6 7 8 9 10 bozo $
  28&nbsp;# (The second 'echo' doesn't execute. Why?)
  29&nbsp;
  30&nbsp;# Occasionally also:
  31&nbsp;# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
  32&nbsp;# (The first 'echo' doesn't execute. Why?)
  33&nbsp;
  34&nbsp;# Very rarely something like:
  35&nbsp;# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20 
  36&nbsp;# The foreground loop preempts the background one.
  37&nbsp;
  38&nbsp;exit 0
  39&nbsp;
  40&nbsp;#  Nasimuddin Ansari suggests adding    sleep 1
  41&nbsp;#+ after the   echo -n "$i"   in lines 6 and 14,
  42&nbsp;#+ for some real fun.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>A command run in the background within a
	      script may cause the script to hang, waiting
	      for a keystroke. Fortunately, there is a <A
HREF="internal.html#WAITHANG"
>remedy</A
> for this.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#LOGOPS1"
>AND logical
	    operator</A
>. </B
>In a <A
HREF="tests.html#TESTCONSTRUCTS1"
>test
		construct</A
>, the <SPAN
CLASS="TOKEN"
>&#38;&#38;</SPAN
> operator causes
		a return of <SPAN
CLASS="RETURNVALUE"
>0</SPAN
> (success) only if
		<I
CLASS="EMPHASIS"
>both</I
> the linked test conditions
		are true.</P
></DIV
></DD
><DT
><A
NAME="DASHREF"
></A
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>option, prefix. </B
>Option flag for a command or filter. Prefix for
	        an operator.</P
></DIV
><P
><TT
CLASS="USERINPUT"
><B
>COMMAND -[Option1][Option2][...]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>ls -al</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>sort -dfu $filename</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>set -- $variable</B
></TT
></P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ $file1 -ot $file2 ]
   2&nbsp;then
   3&nbsp;  echo "File $file1 is older than $file2."
   4&nbsp;fi
   5&nbsp;
   6&nbsp;if [ "$a" -eq "$b" ]
   7&nbsp;then
   8&nbsp;  echo "$a is equal to $b."
   9&nbsp;fi
  10&nbsp;
  11&nbsp;if [ "$c" -eq 24 -a "$d" -eq 47 ]
  12&nbsp;then
  13&nbsp;  echo "$c equals 24 and $d equals 47."
  14&nbsp;fi</PRE
></TD
></TR
></TABLE
>  
	      </P
></DD
><DT
><A
NAME="DASHREF2"
></A
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>redirection from/to <TT
CLASS="FILENAME"
>stdin</TT
> or <TT
CLASS="FILENAME"
>stdout</TT
> [dash]. </B
><A
NAME="COXEX"
></A
></P
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;(cd /source/directory &#38;&#38; tar cf - . ) | (cd /dest/directory &#38;&#38; tar xpvf -)
   2&nbsp;# Move entire file tree from one directory to another
   3&nbsp;# [courtesy Alan Cox &#60;a.cox@swansea.ac.uk&#62;, with a minor change]
   4&nbsp;
   5&nbsp;# 1) cd /source/directory    Source directory, where the files to be moved are.
   6&nbsp;# 2) &#38;&#38;                     "And-list": if the 'cd' operation successful, then execute the next command.
   7&nbsp;# 3) tar cf - .              The 'c' option 'tar' archiving command creates a new archive,
   8&nbsp;#                            the 'f' (file) option, followed by '-' designates the target file as stdout,
   9&nbsp;#                            and do it in current directory tree ('.').
  10&nbsp;# 4) |                       Piped to...
  11&nbsp;# 5) ( ... )                 a subshell
  12&nbsp;# 6) cd /dest/directory      Change to the destination directory.
  13&nbsp;# 7) &#38;&#38;                     "And-list", as above
  14&nbsp;# 8) tar xpvf -              Unarchive ('x'), preserve ownership and file permissions ('p'),
  15&nbsp;#                            and send verbose messages to stdout ('v'),
  16&nbsp;#                            reading data from stdin ('f' followed by '-').
  17&nbsp;#
  18&nbsp;#                            Note that 'x' is a command, and 'p', 'v', 'f' are options.
  19&nbsp;# Whew!
  20&nbsp;
  21&nbsp;
  22&nbsp;
  23&nbsp;# More elegant than, but equivalent to:
  24&nbsp;#   cd source/directory
  25&nbsp;#   tar cf - . | (cd ../dest/directory; tar xpvf -)
  26&nbsp;#
  27&nbsp;#     Also having same effect:
  28&nbsp;# cp -a /source/directory/* /dest/directory
  29&nbsp;#     Or:
  30&nbsp;# cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
  31&nbsp;#     If there are hidden files in /source/directory.</PRE
></TD
></TR
></TABLE
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;bunzip2 linux-2.6.13.tar.bz2 | tar xvf -
   2&nbsp;# --uncompress tar file--    | --then pass it to "tar"--
   3&nbsp;# If "tar" has not been patched to handle "bunzip2",
   4&nbsp;# this needs to be done in two discrete steps, using a pipe.
   5&nbsp;# The purpose of the exercise is to unarchive "bzipped" kernel source.</PRE
></TD
></TR
></TABLE
></P
><P
>Note that in this context the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> is not
            itself a Bash operator, but rather an option recognized by
	    certain UNIX utilities that write to
	    <TT
CLASS="FILENAME"
>stdout</TT
>, such as <B
CLASS="COMMAND"
>tar</B
>,
	    <B
CLASS="COMMAND"
>cat</B
>, etc.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo "whatever" | cat -</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>whatever</TT
> </PRE
></TD
></TR
></TABLE
>
	    </P
><P
>Where a filename is expected,
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> redirects output to
	      <TT
CLASS="FILENAME"
>stdout</TT
> (sometimes seen with
	      <TT
CLASS="USERINPUT"
><B
>tar cf</B
></TT
>), or accepts input from
	      <TT
CLASS="FILENAME"
>stdin</TT
>, rather than from a file. This
	      is a method of using a file-oriented utility as a filter
	      in a pipe.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	    By itself on the command line, <A
HREF="filearchiv.html#FILEREF"
>file</A
> fails with an error message.
	    </P
><P
>	    Add a <SPAN
CLASS="QUOTE"
>"-"</SPAN
> for a more useful result. This causes the
	      shell to await user input.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>abc</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>standard input:              ASCII text</TT
>
 
 
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>file -</B
></TT
>
 <TT
CLASS="USERINPUT"
><B
>#!/bin/bash</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>standard input:              Bourne-Again shell script text executable</TT
>
 	      </PRE
></TD
></TR
></TABLE
>

	      Now the command accepts input from <TT
CLASS="FILENAME"
>stdin</TT
>
	        and analyzes it.
	    </P
><P
>The <SPAN
CLASS="QUOTE"
>"-"</SPAN
> can be used to pipe
	      <TT
CLASS="FILENAME"
>stdout</TT
> to other commands. This permits
	      such stunts as <A
HREF="assortedtips.html#PREPENDREF"
>prepending lines
	      to a file</A
>.</P
><P
>Using <A
HREF="filearchiv.html#DIFFREF"
>diff</A
> to
	      compare a file with a <I
CLASS="EMPHASIS"
>section</I
>
	      of another:</P
><P
><TT
CLASS="USERINPUT"
><B
>grep Linux file1 | diff file2 -</B
></TT
></P
><P
>Finally, a real-world example using
	      <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
> with <A
HREF="filearchiv.html#TARREF"
>tar</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX58"
></A
><P
><B
>Example 3-4. Backup of all files changed in last day</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;#  Backs up all files in current directory modified within last 24 hours
   4&nbsp;#+ in a "tarball" (tarred and gzipped file).
   5&nbsp;
   6&nbsp;BACKUPFILE=backup-$(date +%m-%d-%Y)
   7&nbsp;#                 Embeds date in backup filename.
   8&nbsp;#                 Thanks, Joshua Tschida, for the idea.
   9&nbsp;archive=${1:-$BACKUPFILE}
  10&nbsp;#  If no backup-archive filename specified on command line,
  11&nbsp;#+ it will default to "backup-MM-DD-YYYY.tar.gz."
  12&nbsp;
  13&nbsp;tar cvf - `find . -mtime -1 -type f -print` &#62; $archive.tar
  14&nbsp;gzip $archive.tar
  15&nbsp;echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
  16&nbsp;
  17&nbsp;
  18&nbsp;#  Stephane Chazelas points out that the above code will fail
  19&nbsp;#+ if there are too many files found
  20&nbsp;#+ or if any filenames contain blank characters.
  21&nbsp;
  22&nbsp;# He suggests the following alternatives:
  23&nbsp;# -------------------------------------------------------------------
  24&nbsp;#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
  25&nbsp;#      using the GNU version of "find".
  26&nbsp;
  27&nbsp;
  28&nbsp;#   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
  29&nbsp;#         portable to other UNIX flavors, but much slower.
  30&nbsp;# -------------------------------------------------------------------
  31&nbsp;
  32&nbsp;
  33&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Filenames beginning with
	      <SPAN
CLASS="QUOTE"
>"-"</SPAN
> may cause problems when coupled with the
	      <SPAN
CLASS="QUOTE"
>"-"</SPAN
> redirection operator. A script should
	      check for this and add an appropriate prefix to such
	      filenames, for example <TT
CLASS="FILENAME"
>./-FILENAME</TT
>,
	      <TT
CLASS="FILENAME"
>$PWD/-FILENAME</TT
>, or
	      <TT
CLASS="FILENAME"
>$PATHNAME/-FILENAME</TT
>.</P
><P
>If the value of a variable begins with a
	        <TT
CLASS="REPLACEABLE"
><I
>-</I
></TT
>, this may likewise create
		problems.
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;var="-n"
   2&nbsp;echo $var		
   3&nbsp;# Has the effect of "echo -n", and outputs nothing.</PRE
></TD
></TR
></TABLE
>
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>A <B
CLASS="COMMAND"
>cd -</B
> command changes to the
		previous working directory. This uses the
		<A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> <A
HREF="othertypesv.html#ENVREF"
>environmental variable</A
>.</P
></DIV
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do not confuse the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> used in this
		sense with the <SPAN
CLASS="QUOTE"
>"-"</SPAN
> redirection
		operator just discussed. The interpretation of the
		<SPAN
CLASS="QUOTE"
>"-"</SPAN
> depends on the context in which it
		appears.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Minus. </B
>Minus sign in an <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>=</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Equals. </B
><A
HREF="varassignment.html#EQREF"
>Assignment operator</A
>
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;a=28
   2&nbsp;echo $a   # 28</PRE
></TD
></TR
></TABLE
></P
></DIV
><P
>In a <A
HREF="comparison-ops.html#EQUALSIGNREF"
>different context</A
>,
	      the <SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="TOKEN"
>=</SPAN
>"</SPAN
> is a <A
HREF="comparison-ops.html#SCOMPARISON1"
>string comparison</A
>
	      operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Plus. </B
>Addition  <A
HREF="operations.html#AROPS1"
>arithmetic
	        operator</A
>.</P
></DIV
><P
>In a <A
HREF="regexp.html#PLUSREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>+</SPAN
> is a <A
HREF="regexp.html"
>Regular
	      Expression</A
> operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>Option. </B
>Option flag for a command or filter.</P
></DIV
><P
>Certain commands and <A
HREF="internal.html#BUILTINREF"
>builtins</A
> use the
	      <SPAN
CLASS="TOKEN"
>+</SPAN
> to enable certain options and the
	      <SPAN
CLASS="TOKEN"
>-</SPAN
> to disable them.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>%</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="operations.html#MODULOREF"
>modulo</A
>. </B
>Modulo (remainder of a division) <A
HREF="operations.html#AROPS1"
>arithmetic
	        operation</A
>.</P
></DIV
><P
>In a <A
HREF="parameter-substitution.html#PCTPATREF"
>different context</A
>,
	      the <SPAN
CLASS="TOKEN"
>%</SPAN
> is a <A
HREF="parameter-substitution.html#PSUB2"
>pattern
	      matching</A
> operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>~</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>home directory [tilde]. </B
>This corresponds to the <A
HREF="variables2.html#HOMEDIRREF"
>$HOME</A
> internal variable.

	      <I
CLASS="EMPHASIS"
>~bozo</I
> is bozo's home directory,
		and <B
CLASS="COMMAND"
>ls ~bozo</B
> lists the contents of it.
		<SPAN
CLASS="TOKEN"
>~/</SPAN
> is the current user's home directory,
		and <B
CLASS="COMMAND"
>ls ~/</B
> lists the contents of it.

	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
> <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~bozo</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~/</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo/</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~:</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>/home/bozo:</TT
>
 
 <TT
CLASS="PROMPT"
>bash$ </TT
><TT
CLASS="USERINPUT"
><B
>echo ~nonexistent-user</B
></TT
>
 <TT
CLASS="COMPUTEROUTPUT"
>~nonexistent-user</TT
>
 	      </PRE
></TD
></TR
></TABLE
>
	      </P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>~+</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>current working directory. </B
>This corresponds to the <A
HREF="variables2.html#PWDREF"
>$PWD</A
> internal variable.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>~-</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>previous working directory. </B
>This corresponds to the <A
HREF="variables2.html#OLDPWD"
>$OLDPWD</A
> internal variable.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>=~</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
><A
HREF="bashver3.html#REGEXMATCHREF"
>regular
	  expression match</A
>. </B
>This operator was introduced with <A
HREF="bashver3.html#BASH3REF"
>version 3</A
> of Bash.</P
></DIV
></DD
><DT
><SPAN
CLASS="TOKEN"
>^</SPAN
></DT
><DD
><DIV
CLASS="FORMALPARA"
><P
><B
>beginning-of-line. </B
>In a <A
HREF="regexp.html#REGEXREF"
>regular expression</A
>, a
	        <SPAN
CLASS="QUOTE"
>"^"</SPAN
> addresses the beginning of a line of text.</P
></DIV
></DD
><DT
>Control Characters</DT
><DD
><P
><A
NAME="CONTROLCHARREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
> change the behavior of the
	        terminal or text display. </B
>A control character is a <B
CLASS="KEYCAP"
>CONTROL</B
>
	      + <B
CLASS="KEYCAP"
>key</B
> combination.</P
></DIV
><P
>Control characters are not normally useful inside a
	    script.</P
><UL
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-B</B
></TT
></P
><P
>Backspace (nondestructive).</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-C</B
></TT
></P
><P
>Break. Terminate a foreground job.</P
></LI
><LI
><P
><A
NAME="CTLDREF"
></A
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
></P
><P
>Log out from a shell (similar to
		  <A
HREF="exit-status.html#EXITCOMMANDREF"
>exit</A
>).</P
><P
><SPAN
CLASS="QUOTE"
>"EOF"</SPAN
> (end of file). This also
		  terminates input from <TT
CLASS="FILENAME"
>stdin</TT
>.</P
><P
>When typing text on the console or in an
                  <I
CLASS="FIRSTTERM"
>xterm</I
> window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
> erases the character under the
		  cursor. When there are no characters present,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-D</B
></TT
> logs out of the session, as
		  expected. In an xterm window, this has the effect of closing
		  the window.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-G</B
></TT
></P
><P
><SPAN
CLASS="QUOTE"
>"BEL"</SPAN
> (beep). On some old-time teletype
		  terminals, this would actually ring a bell.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-H</B
></TT
></P
><P
><SPAN
CLASS="QUOTE"
>"Rubout"</SPAN
> (destructive backspace). Erases
		  characters the cursor backs over while backspacing.</P
><P
>		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Embedding Ctl-H in a string.
   3&nbsp;
   4&nbsp;a="^H^H"                  # Two Ctl-H's (backspaces).
   5&nbsp;echo "abcdef"             # abcdef
   6&nbsp;echo -n "abcdef$a "       # abcd f
   7&nbsp;#  Space at end  ^              ^ Backspaces twice.
   8&nbsp;echo -n "abcdef$a"        # abcdef
   9&nbsp;#  No space at end                Doesn't backspace (why?).
  10&nbsp;                          # Results may not be quite as expected.
  11&nbsp;echo; echo</PRE
></TD
></TR
></TABLE
>
                </P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-I</B
></TT
></P
><P
>Horizontal tab.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-J</B
></TT
></P
><P
>Newline (line feed). In a script, may also be expressed
		  in octal notation -- '\012' or in hexadecimal -- '\x0a'.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-K</B
></TT
></P
><P
>Vertical tab.</P
><P
>When typing text on the console or in an
                  <I
CLASS="EMPHASIS"
>xterm</I
> window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-K</B
></TT
> erases from the character
		  under the cursor to end of line.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-L</B
></TT
></P
><P
>Formfeed (clear the terminal screen). This has
		  the same effect as the <A
HREF="terminalccmds.html#CLEARREF"
>clear</A
> command.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-M</B
></TT
></P
><P
>Carriage return.</P
><P
>		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# Thank you, Lee Maschmeyer, for this example.
   3&nbsp;
   4&nbsp;read -n 1 -s -p $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
   5&nbsp;                                  # Of course, '0d' is the hex equivalent of Control-M.
   6&nbsp;echo &#62;&#38;2   #  The '-s' makes anything typed silent,
   7&nbsp;           #+ so it is necessary to go to new line explicitly.
   8&nbsp;
   9&nbsp;read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
  10&nbsp;           #  '0a' is the hex equivalent of Control-J, linefeed.
  11&nbsp;echo &#62;&#38;2
  12&nbsp;
  13&nbsp;###
  14&nbsp;
  15&nbsp;read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
  16&nbsp;echo &#62;&#38;2   #  Control-K is vertical tab.
  17&nbsp;
  18&nbsp;# A better example of the effect of a vertical tab is:
  19&nbsp;
  20&nbsp;var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
  21&nbsp;echo "$var"
  22&nbsp;#  This works the same way as the above example. However:
  23&nbsp;echo "$var" | col
  24&nbsp;#  This causes the right end of the line to be higher than the left end.
  25&nbsp;#  It also explains why we started and ended with a line feed --
  26&nbsp;#+ to avoid a garbled screen.
  27&nbsp;
  28&nbsp;# As Lee Maschmeyer explains:
  29&nbsp;# --------------------------
  30&nbsp;#  In the [first vertical tab example] . . . the vertical tab
  31&nbsp;#+ makes the printing go straight down without a carriage return.
  32&nbsp;#  This is true only on devices, such as the Linux console,
  33&nbsp;#+ that can't go "backward."
  34&nbsp;#  The real purpose of VT is to go straight UP, not down.
  35&nbsp;#  It can be used to print superscripts on a printer.
  36&nbsp;#  The col utility can be used to emulate the proper behavior of VT.
  37&nbsp;
  38&nbsp;exit 0</PRE
></TD
></TR
></TABLE
>
		</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Q</B
></TT
></P
><P
>Resume (XON).</P
><P
>This resumes <TT
CLASS="FILENAME"
>stdin</TT
> in a terminal.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-S</B
></TT
></P
><P
>Suspend (XOFF).</P
><P
>This freezes <TT
CLASS="FILENAME"
>stdin</TT
> in a terminal.
		  (Use Ctl-Q to restore input.)</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
></P
><P
>Erase a line of input, from the cursor backward to
		  beginning of line. In some settings,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-U</B
></TT
> erases the entire
		  line of input, <I
CLASS="EMPHASIS"
>regardless of cursor
		  position</I
>.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
></P
><P
>When inputting text, <TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
>
		  permits inserting control characters. For example, the
		  following two are equivalent:
		    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;echo -e '\x0a'
   2&nbsp;echo &#60;Ctl-V&#62;&#60;Ctl-J&#62;</PRE
></TD
></TR
></TABLE
></P
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-V</B
></TT
> is primarily useful from
		within a text editor.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
></P
><P
>When typing text on the console or in an xterm window,
		  <TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
> erases from the character
		  under the cursor backwards to the first instance of
		  whitespace. In some settings, <TT
CLASS="USERINPUT"
><B
>Ctl-W</B
></TT
>
		  erases backwards to first non-alphanumeric character.</P
></LI
><LI
><P
><TT
CLASS="USERINPUT"
><B
>Ctl-Z</B
></TT
></P
><P
>Pause a foreground job.</P
></LI
></UL
></DD
><DT
>Whitespace</DT
><DD
><P
><A
NAME="WHITESPACEREF"
></A
></P
><DIV
CLASS="FORMALPARA"
><P
><B
>functions as a separator, separating commands or variables. </B
>Whitespace consists of either
		<I
CLASS="FIRSTTERM"
>spaces</I
>,
		<I
CLASS="FIRSTTERM"
>tabs</I
>, <I
CLASS="FIRSTTERM"
>blank
		lines</I
>, or any combination thereof.

		  <A
NAME="AEN1676"
HREF="#FTN.AEN1676"
>[3]</A
>

		In some contexts, such as <A
HREF="gotchas.html#WSBAD"
>variable
		assignment</A
>, whitespace is not permitted, and
		results in a syntax error.</P
></DIV
><P
>Blank lines have no effect on the action of a script,
	    and are therefore useful for visually separating functional
	    sections.</P
><P
><A
HREF="variables2.html#IFSREF"
>$IFS</A
>, the special variable
	    separating fields of input to certain commands, defaults
	    to whitespace.</P
><P
>To preserve whitespace within a string or in a variable,
	        use <A
HREF="quoting.html#QUOTINGREF"
>quoting</A
>.</P
></DD
></DL
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN882"
HREF="special-chars.html#AEN882"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The shell does the <I
CLASS="EMPHASIS"
>brace
	       expansion</I
>. The command itself acts upon the
	       <I
CLASS="EMPHASIS"
>result</I
> of the expansion.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN931"
HREF="special-chars.html#AEN931"
>[2]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Exception: a code block in braces as
		  part of a pipe <I
CLASS="EMPHASIS"
>may</I
> run as a
		  <A
HREF="subshells.html#SUBSHELLSREF"
>subshell</A
>.

		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;ls | { read firstline; read secondline; }
   2&nbsp;#  Error. The code block in braces runs as a subshell,
   3&nbsp;#+ so the output of "ls" cannot be passed to variables within the block.
   4&nbsp;echo "First line is $firstline; second line is $secondline"  # Will not work.
   5&nbsp;
   6&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1676"
HREF="special-chars.html#AEN1676"
>[3]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>A linefeed (<SPAN
CLASS="QUOTE"
>"newline"</SPAN
>)
		    is also a whitespace character. This explains why
		    a <I
CLASS="EMPHASIS"
>blank line</I
>, consisting only
		    of a linefeed, is considered whitespace.</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="part2.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="variables.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Basics</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="part2.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Introduction to Variables and Parameters</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>